{"version":3,"sources":["../../src/sanitizer/cssparser.js"],"names":["toLowerCase","parseCssStylesheet","parseCssDeclarations","cssText","handler","toks","i","n","length","statement","tok","charAt","atrule","ruleset","blockok","start","s","e","slice","block","ch","selector","declaration","allowSemi","brackets","stackLast","ident","skipDeclaration","property","test","value","valuelen","j"],"mappings":"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","file":"cssparser.js","sourcesContent":["/* eslint-disable */\n\n//\n// FROM: https://raw.githubusercontent.com/google/caja/1056be89dad487f9178d89f462fe5cb207c7e604/src/com/google/caja/plugin/cssparser.js\n//\n\n// Copyright (C) 2010 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview\n * Utilities for dealing with CSS source code.\n *\n * @author mikesamuel@gmail.com\n * \\@requires lexCss\n * \\@overrides window\n * \\@provides parseCssStylesheet, parseCssDeclarations\n */\n\nimport { lexCss } from './csslexer';\n\n// The Turkish i seems to be a non-issue, but abort in case it is.\nif ('I'.toLowerCase() !== 'i') { throw 'I/i problem'; }\n\n/**\n * parseCssStylesheet takes a chunk of CSS text and a handler object with\n * methods that it calls as below:\n * <pre>\n * // At the beginning of a stylesheet.\n * handler.startStylesheet();\n *\n * // For an @foo rule ended by a semicolon: @import \"foo.css\";\n * handler.startAtrule('@import', ['\"foo.css\"']);\n * handler.endAtrule();\n *\n * // For an @foo rule ended with a block. @media print { ... }\n * handler.startAtrule('@media', ['print']);\n * handler.startBlock();\n * // Calls to contents elided.  Probably selectors and declarations as below.\n * handler.endBlock();\n * handler.endAtrule();\n *\n * // For a ruleset: p.clazz q, s { color: blue; }\n * handler.startRuleset(['p', '.', 'clazz', ' ', 'q', ',', ' ', 's']);\n * handler.declaration('color', ['blue']);\n * handler.endRuleset();\n *\n * // At the end of a stylesheet.\n * handler.endStylesheet();\n * </pre>\n * When errors are encountered, the parser drops the useless tokens and\n * attempts to resume parsing.\n *\n * @param {string} cssText CSS3 content to parse as a stylesheet.\n * @param {Object} handler An object like <pre>{\n *   startStylesheet: function () { ... },\n *   endStylesheet: function () { ... },\n *   startAtrule: function (atIdent, headerArray) { ... },\n *   endAtrule: function () { ... },\n *   startBlock: function () { ... },\n *   endBlock: function () { ... },\n *   startRuleset: function (selectorArray) { ... },\n *   endRuleset: function () { ... },\n *   declaration: function (property, valueArray) { ... },\n * }</pre>\n */\nvar parseCssStylesheet;\n\n/**\n * parseCssDeclarations parses a run of declaration productions as seen in the\n * body of the HTML5 {@code style} attribute.\n *\n * @param {string} cssText CSS3 content to parse as a run of declarations.\n * @param {Object} handler An object like <pre>{\n *   declaration: function (property, valueArray) { ... },\n * }</pre>\n */\nvar parseCssDeclarations;\n\n(function () {\n  // stylesheet  : [ CDO | CDC | S | statement ]*;\n  parseCssStylesheet = function(cssText, handler) {\n    var toks = lexCss(cssText);\n    if (handler['startStylesheet']) { handler['startStylesheet'](); }\n    for (var i = 0, n = toks.length; i < n;) {\n      // CDO and CDC (\"<!--\" and \"-->\") are converted to space by the lexer.\n      i = toks[i] === ' ' ? i+1 : statement(toks, i, n, handler);\n    }\n    if (handler['endStylesheet']) { handler['endStylesheet'](); }\n  };\n\n  // statement   : ruleset | at-rule;\n  function statement(toks, i, n, handler) {\n    if (i < n) {\n      var tok = toks[i];\n      if (tok.charAt(0) === '@') {\n        return atrule(toks, i, n, handler, true);\n      } else {\n        return ruleset(toks, i, n, handler);\n      }\n    } else {\n      return i;\n    }\n  }\n\n  // at-rule     : ATKEYWORD S* any* [ block | ';' S* ];\n  function atrule(toks, i, n, handler, blockok) {\n    var start = i++;\n    while (i < n && toks[i] !== '{' && toks[i] !== ';') {\n      ++i;\n    }\n    if (i < n && (blockok || toks[i] === ';')) {\n      var s = start+1, e = i;\n      if (s < n && toks[s] === ' ') { ++s; }\n      if (e > s && toks[e-1] === ' ') { --e; }\n      if (handler['startAtrule']) {\n        handler['startAtrule'](toks[start].toLowerCase(), toks.slice(s, e));\n      }\n      i = (toks[i] === '{')\n          ? block(toks, i, n, handler)\n          : i+1;  // Skip over ';'\n      if (handler['endAtrule']) {\n        handler['endAtrule']();\n      }\n    }\n    // Else we reached end of input or are missing a semicolon.\n    // Drop the rule on the floor.\n    return i;\n  }\n\n  // block       : '{' S* [ any | block | ATKEYWORD S* | ';' S* ]* '}' S*;\n   // Assumes the leading '{' has been verified by callers.\n  function block(toks, i, n, handler) {\n    ++i; //  skip over '{'\n    if (handler['startBlock']) { handler['startBlock'](); }\n    while (i < n) {\n      var ch = toks[i].charAt(0);\n      if (ch == '}') {\n        ++i;\n        break;\n      }\n      if (ch === ' ' || ch === ';') {\n        i = i+1;\n      } else if (ch === '@') {\n        i = atrule(toks, i, n, handler, false);\n      } else if (ch === '{') {\n        i = block(toks, i, n, handler);\n      } else {\n        // Instead of using (any* block) to subsume ruleset we allow either\n        // blocks or rulesets with a non-blank selector.\n        // This is more restrictive but does not require atrule specific\n        // parse tree fixup to realize that the contents of the block in\n        //    @media print { ... }\n        // is a ruleset.  We just don't care about any block carrying at-rules\n        // whose body content is not ruleset content.\n        i = ruleset(toks, i, n, handler);\n      }\n    }\n    if (handler['endBlock']) { handler['endBlock'](); }\n    return i;\n  }\n\n  // ruleset    : selector? '{' S* declaration? [ ';' S* declaration? ]* '}' S*;\n  function ruleset(toks, i, n, handler) {\n    // toks[s:e] are the selector tokens including internal whitespace.\n    var s = i, e = selector(toks, i, n, true);\n    if (e < 0) {\n      // Skip malformed content per selector calling convention.\n      e = ~e;\n      // Make sure we skip at least one token.\n      return e === s ? e+1 : e;\n    }\n    var tok = toks[e];\n    if (tok !== '{') {\n      // Make sure we skip at least one token.\n      return e === s ? e+1 : e;\n    }\n    i = e+1;  // Skip over '{'\n    // Don't include any trailing space in the selector slice.\n    if (e > s && toks[e-1] === ' ') { --e; }\n    if (handler['startRuleset']) {\n      handler['startRuleset'](toks.slice(s, e));\n    }\n    while (i < n) {\n      tok = toks[i];\n      if (tok === '}') {\n        ++i;\n        break;\n      }\n      if (tok === ' ') {\n        i = i+1;\n      } else {\n        i = declaration(toks, i, n, handler);\n      }\n    }\n    if (handler['endRuleset']) {\n      handler['endRuleset']();\n    }\n    return i;\n  }\n\n  // selector    : any+;\n  // any         : [ IDENT | NUMBER | PERCENTAGE | DIMENSION | STRING\n  //               | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES\n  //               | FUNCTION S* any* ')' | DASHMATCH | '(' S* any* ')'\n  //               | '[' S* any* ']' ] S*;\n  // A negative return value, rv, indicates the selector was malformed and\n  // the index at which we stopped is ~rv.\n  function selector(toks, i, n, allowSemi) {\n    var s = i;\n    // The definition of any above can be summed up as\n    //   \"any run of token except ('[', ']', '(', ')', ':', ';', '{', '}')\n    //    or nested runs of parenthesized tokens or square bracketed tokens\".\n    // Spaces are significant in the selector.\n    // Selector is used as (selector?) so the below looks for (any*) for\n    // simplicity.\n    var tok;\n    // Keeping a stack pointer actually causes this to minify better since\n    // \".length\" and \".push\" are a lo of chars.\n    var brackets = [], stackLast = -1;\n    for (;i < n; ++i) {\n      tok = toks[i].charAt(0);\n      if (tok === '[' || tok === '(') {\n        brackets[++stackLast] = tok;\n      } else if ((tok === ']' && brackets[stackLast] === '[') ||\n                 (tok === ')' && brackets[stackLast] === '(')) {\n        --stackLast;\n      } else if (tok === '{' || tok === '}' || tok === ';' || tok === '@'\n                 || (tok === ':' && !allowSemi)) {\n        break;\n      }\n    }\n    if (stackLast >= 0) {\n      // Returns the bitwise inverse of i+1 to indicate an error in the\n      // token stream so that clients can ignore it.\n      i = ~(i+1);\n    }\n    return i;\n  }\n\n  var ident = /^-?[a-z]/i;\n\n  function skipDeclaration(toks, i, n) {\n    // TODO(felix8a): maybe skip balanced pairs of {}\n    while (i < n && toks[i] !== ';' && toks[i] !== '}') { ++i; }\n    return i < n && toks[i] === ';' ? i+1 : i;\n  }\n\n  // declaration : property ':' S* value;\n  // property    : IDENT S*;\n  // value       : [ any | block | ATKEYWORD S* ]+;\n  function declaration(toks, i, n, handler) {\n    var property = toks[i++];\n    if (!ident.test(property)) {\n      return skipDeclaration(toks, i, n);\n    }\n    var tok;\n    if (i < n && toks[i] === ' ') { ++i; }\n    if (i == n || toks[i] !== ':') {\n      return skipDeclaration(toks, i, n);\n    }\n    ++i;\n    if (i < n && toks[i] === ' ') { ++i; }\n\n    // None of the rules we care about want atrules or blocks in value, so\n    // we look for any+ but that is the same as selector but not zero-length.\n    // This gets us the benefit of not emitting any value with mismatched\n    // brackets.\n    var s = i, e = selector(toks, i, n, false);\n    if (e < 0) {\n      // Skip malformed content per selector calling convention.\n      e = ~e;\n    } else {\n      var value = [], valuelen = 0;\n      for (var j = s; j < e; ++j) {\n        tok = toks[j];\n        if (tok !== ' ') {\n          value[valuelen++] = tok;\n        }\n      }\n      // One of the following is now true:\n      // (1) e is flush with the end of the tokens as in <... style=\"x:y\">.\n      // (2) tok[e] points to a ';' in which case we need to consume the semi.\n      // (3) tok[e] points to a '}' in which case we don't consume it.\n      // (4) else there is bogus unparsed value content at toks[e:].\n      // Allow declaration flush with end for style attr body.\n      if (e < n) {  // 2, 3, or 4\n        do {\n          tok = toks[e];\n          if (tok === ';' || tok === '}') { break; }\n          // Don't emit the property if there is questionable trailing content.\n          valuelen = 0;\n        } while (++e < n);\n        if (tok === ';') {\n          ++e;\n        }\n      }\n      if (valuelen && handler['declaration']) {\n        // TODO: coerce non-keyword ident tokens to quoted strings.\n        handler['declaration'](property.toLowerCase(), value);\n      }\n    }\n    return e;\n  }\n\n  parseCssDeclarations = function(cssText, handler) {\n    var toks = lexCss(cssText);\n    for (var i = 0, n = toks.length; i < n;) {\n      i = toks[i] !== ' ' ? declaration(toks, i, n, handler) : i+1;\n    }\n  };\n})();\n\nexport {\n  parseCssStylesheet,\n  parseCssDeclarations\n};\n"]}